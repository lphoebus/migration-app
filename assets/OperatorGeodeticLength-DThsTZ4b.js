import{hm as U,hn as ee}from"./index-Cv1x7wWx.js";import{A as ie,aY as te,n as G,aZ as be,l as Ye,G as Z,a_ as qe,$ as Ae,b as E,a$ as x,P as me,D as le,a as Q,k as Ce,f as Oe,i as Ie,c as se,b0 as b,aa as j,b1 as Xe,b2 as B,ab as V,j as Te,v as Pe,a1 as ce,am as ze,b3 as Ee,Q as Ge,O as ne,b4 as De,b5 as pe,b6 as Je,b7 as K,b8 as re,aO as Be,b9 as Re,ba as Me,bb as $,aM as v,bc as ve,bd as we,be as he,bf as H,bg as F,K as Ve,bh as xe,U as Le,o as L,aX as Ne,bi as He,bj as Qe}from"./ProjectionTransformation-B_Fzdc_x.js";import"./jsonConverter-D8E8HcXe.js";import{n as Ze,s as We,a as Ke,c as et,u as tt,b as st,m as nt,d as it,e as at,p as rt,f as _t,g as ot,h as ht,i as mt,j as lt,k as ut,l as ct,o as pt,q as gt,r as dt,t as ft,v as St,w as yt,x as Pt,y as Et,z as xt,A as bt,B as At,C as Ct,D as Tt,E as Mt,F as Rt,G as vt,H as wt,I as Nt,J as $t,K as qt,L as Ot,M as It,N as zt,O as Gt,P as Dt,Q as Lt,R as jt,S as kt,T as Ft,U as Ut,V as Yt,W as Xt,X as Jt}from"./operators-DH_0kJgQ.js";const ys=Object.freeze(Object.defineProperty({__proto__:null,execute:Ze,supportsCurves:We},Symbol.toStringTag,{value:"Module"})),Ps=Object.freeze(Object.defineProperty({__proto__:null,execute:Ke,supportsCurves:et},Symbol.toStringTag,{value:"Module"})),Es=Object.freeze(Object.defineProperty({__proto__:null,execute:tt,executeMany:st,supportsCurves:nt},Symbol.toStringTag,{value:"Module"})),xs=Object.freeze(Object.defineProperty({__proto__:null,execute:it,supportsCurves:at},Symbol.toStringTag,{value:"Module"})),bs=Object.freeze(Object.defineProperty({__proto__:null,execute:rt,executeMany:_t,supportsCurves:ot},Symbol.toStringTag,{value:"Module"})),As=Object.freeze(Object.defineProperty({__proto__:null,execute:ht,executeMany:mt,supportsCurves:lt},Symbol.toStringTag,{value:"Module"})),Cs=Object.freeze(Object.defineProperty({__proto__:null,execute:ut,supportsCurves:ct},Symbol.toStringTag,{value:"Module"})),Ts=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:pt,execute:gt,supportsCurves:dt},Symbol.toStringTag,{value:"Module"})),Ms=Object.freeze(Object.defineProperty({__proto__:null,execute:ft,executeMany:St,supportsCurves:yt},Symbol.toStringTag,{value:"Module"})),Rs=Object.freeze(Object.defineProperty({__proto__:null,execute:Pt,isLoaded:Et,load:xt,get supportsCurves(){return bt}},Symbol.toStringTag,{value:"Module"})),vs=Object.freeze(Object.defineProperty({__proto__:null,execute:At,executeMany:Ct,isLoaded:Tt,load:Mt,get supportsCurves(){return Rt}},Symbol.toStringTag,{value:"Module"})),ws=Object.freeze(Object.defineProperty({__proto__:null,execute:vt,isLoaded:wt,load:Nt,get supportsCurves(){return $t}},Symbol.toStringTag,{value:"Module"})),Ns=Object.freeze(Object.defineProperty({__proto__:null,execute:qt,executeMany:Ot,supportsCurves:It},Symbol.toStringTag,{value:"Module"})),$s=Object.freeze(Object.defineProperty({__proto__:null,getNearestCoordinate:zt,getNearestVertex:Gt,getNearestVertices:Dt,supportsCurves:Lt},Symbol.toStringTag,{value:"Module"})),qs=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:jt,execute:kt,isValidDE9IM:Ft,supportsCurves:Ut},Symbol.toStringTag,{value:"Module"})),Os=Object.freeze(Object.defineProperty({__proto__:null,execute:Yt,executeMany:Xt,supportsCurves:Jt},Symbol.toStringTag,{value:"Module"}));function ge(){return{m_pGcs:new E,m_xyz:new x,m_factor:Number.NaN,m_geoLength:Number.NaN,setValues:Bt,setLength:Vt,assign:Ht}}function Bt(u,e,t,s){this.m_factor=u,this.m_pGcs.assign(e),this.m_xyz.assign(s),this.m_geoLength=t}function Vt(u){this.m_geoLength=u}function Ht(u){this.m_pGcs.assign(u.m_pGcs),this.m_xyz.assign(u.m_xyz),this.m_factor=u.m_factor,this.m_geoLength=u.m_geoLength}class je{getOperatorType(){return 10315}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}_ExecuteShapePreservingLength(e,t,s,i,a){if(e.hasNonLinearSegments()&&(e=new ie().execute(e,0,t.getTolerance(0),0,a)),t.isPannable()){let n=90,r=-90;if(s.getUnit().getUnitToBaseFactor()===1&&(n*=Math.PI/180,r*=Math.PI/180),t.getCoordinateSystemType()===2){let l=null;const _=[0,0,0,0];l=t.getPECoordSys(),_[0]=0,_[1]=n,_[2]=0,_[3]=r,te.geogToProj(l,2,_),n=_[1],r=_[3]}const o=new G;e.queryEnvelope(o),o.ymin=r,o.ymax=n,e=new be().execute(e,o,t,a)}else{const n=t.getPCSHorizon();(e=new Ye().execute(e,n,t,a))===n&&(e=e.clone())}return e.isEmpty()?0:this._ExecuteIterativeApproach(e,t,s,i,1,a)}_ExecuteIterativeApproach(e,t,s,i,a,n){const r=Z();s.querySpheroidData(r);const o=r.majorSemiAxis,l=r.e2,_=s.getUnit().getUnitToBaseFactor(),h=40,m=qe(ge,h),c=Ae(h,Number.NaN),p=ge(),g=ge();let f;const d=[0,0,0,0],P=t.getPECoordSys(),S=new E,y=new E,T=new E,C=new E,M=new E;let O=0;const k=e.querySegmentIterator();for(;k.nextPath();)for(;k.hasNextSegment();){const Y=k.nextSegment();S.assign(Y.getStartXY()),y.assign(Y.getEndXY()),t.getCoordinateSystemType()===2?(d[0]=S.x,d[1]=S.y,d[2]=y.x,d[3]=y.y,te.projToGeog(P,2,d),T.x=d[0]*_,T.y=d[1]*_,C.x=d[2]*_,C.y=d[3]*_):(T.setCoordsPoint2D(S),C.setCoordsPoint2D(y),T.scale(_),C.scale(_));const q=new x,I=new x;de(o,l,T,q),de(o,l,C,I);let R=_e(o,q,I);p.setValues(0,T,Number.NaN,q),g.setValues(1,C,R,I),f=a,m[0].assign(g),c[0]=a;let A=0;for(;;){A>128&&se("iterations exceeded");const w=.5*(p.m_factor+g.m_factor),N=Y.getCoord2D(w);t.getCoordinateSystemType()===2?(d[0]=N.x,d[1]=N.y,te.projToGeog(P,1,d),M.x=d[0]*_,M.y=d[1]*_):(M.setCoordsPoint2D(N),M.scale(_)),T.setCoordsPoint2D(p.m_pGcs),C.setCoordsPoint2D(g.m_pGcs);const D=new x;de(o,l,M,D);const X=_e(o,p.m_xyz,D),J=_e(o,g.m_xyz,D);R=g.m_geoLength,Number.isNaN(R)&&(R=_e(o,p.m_xyz,g.m_xyz));const z=X+J,W=f===a&&z>=20&&Math.abs(z-R)>1e-8*(R+z);if(A+2<h&&(W||Math.abs(z-R)>0&&f>0))g.setLength(J),m[A].assign(g),g.setValues(w,M,X,D),m[++A].assign(g),W?(f=a,c[A]=a):(f--,c[A-1]=f,c[A]=f);else{if(O+=z,A===0)break;p.assign(g),g.assign(m[--A]),f=c[A]}}}return O}execute(e,t,s){if(t&&t.getCoordinateSystemType()!==0||me(""),e.isEmpty()||e.getDimension()<1)return 0;let i=null;const a=t.getGCS();a!==t&&(i=le(t,a,null));const n=e.getGeometryType();if(n===Q.enumEnvelope){const r=new Ce;return r.addEnvelope(e,!1),this._ExecuteShapePreservingLength(r,t,a,i,s)}if(Oe(n)){const r=new Ie;return r.addSegment(e,!0),this._ExecuteShapePreservingLength(r,t,a,i,s)}return this._ExecuteShapePreservingLength(e,t,a,i,s)}}function de(u,e,t,s){s.assign(b(u,e,t))}function _e(u,e,t){const s=u,i=new x;i.setSub(e,t);const a=i.length();return 2*s*Math.asin(a/(2*s))}let Qt=class{constructor(e,t,s,i,a=0,n=4){this.m_ptDistFrom=new E,this.m_segStartPt=new E,this.m_segEndPt=new E,this.m_geodeticLength=new j,this.m_az12=new j,this.m_minGeodeticDist=new j,this.m_segStartPt3d=new x,this.m_segEndPt3d=new x,this.m_sr=i,this.m_distCurveType=a,this.m_segCurveType=n,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=this.m_sr.getCoordinateSystemType()===2&&this.m_sr.isPannable();const r=Z();this.m_inputGCS.querySpheroidData(r),this.m_a=r.majorSemiAxis,this.m_eSquared=r.e2,this.setPointDistFrom(e),this.setSegmentEndPoints(t,s)}setSegmentEndPoints(e,t){this.m_segStartPt.assign(e),this.m_segEndPt.assign(t),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),this.m_segCurveType===2&&(this.m_segStartPt3d.assign(b(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(b(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(e){this.m_ptDistFrom.assign(e),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(e){this.m_segCurveType=e}setDistanceCurveType(e){this.m_distCurveType=e}makeFunctor(){return e=>{let t;switch(this.m_segCurveType){case 0:case 1:case 3:{const s={stack:[],error:void 0,hasError:!1};try{const i=U(s,new j,!1),a=U(s,new j,!1);V.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*e,this.m_az12.val,i,a,this.m_segCurveType),t=new E(i.val,a.val);break}catch(i){s.error=i,s.hasError=!0}finally{ee(s)}}case 2:{const s=x.lerp(this.m_segStartPt3d,this.m_segEndPt3d,e);t=B(this.m_a,this.m_eSquared,s);break}case 4:t=E.lerp(this.m_segStartPt,this.m_segEndPt,e),this.m_bIsPannablePcs&&(Xe(this.m_sr,0,[t],1),t.mulThis(this.m_rpu));break;default:se("Invalid curve type")}return V.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,t.x,t.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:V.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=E.distance(this.m_segStartPt,this.m_segEndPt);break;default:se("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}};class Zt{constructor(e,t,s,i,a=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=i,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=s.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=s.getCoordinateSystemType()===2,this.PEProjcs=s.getPECoordSys(),this.m_points=Ae(2*a,Number.NaN)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&te.projToGeogCenter(this.PEProjcs,1,t,0);const s=Math.sin(t[1]*this.m_cRpu);return this.m_cE2===0?s:-Math.log((1-this.m_cE*s)/(1+this.m_cE*s))*this.m_c1By2e+s/(1-this.m_cE2*s*s)}}}function Wt(u,e,t){const s=new G;u.queryEnvelope(s);const i=Ve(e,s,!0).total(),a=e.getPannableExtent();a.xmin=s.xmin-10*i,a.xmax=s.xmax+10*i;const n=new be().execute(u,a,e,t).getImpl().querySegmentIterator();n.stripAttributes();const r=Z();e.querySpheroidData(r);const o=r.e2,l=o===0?2:1,_=new E(0,0),h=new E(0,0),m=new K(0),c=new Zt(_,h,e,o,100);for(;n.nextPath();)for(;n.hasNextSegment();){const g=n.nextSegment();_.assign(g.getStartXY()),h.assign(g.getEndXY()),c.setSegmentEndPoints(_,h);const f=he(6,0,1,1e-12,1e-15,c.makeFunctor());m.pe((h.x-_.x)*f)}const p=r.majorSemiAxis;return l*p*p*(1-o)*Math.PI*m.getResult()/e.getPannableExtent().width()}function Kt(u,e,t,s,i){const a=ss(u,e,i);let n=$e(u,a.first,t,s,i),r=1,o=0,l=0;do{if(r++,a.first*=.5,a.first<50*e.getTolerance(0))return n;a.second*=2,l=$e(u,a.first,t,s,i),o=Math.abs(l-n),n=l}while(Math.abs(n)>1&&o>1e-8*Math.abs(n)&&(a.second<65e3&&r<8||r<4));return l}function $e(u,e,t,s,i){const a=new ie().execute(u,e,0,0,i);let n;n=s?new ne().execute(a,s,i):a;const r=t.getUnit().getUnitToBaseFactor()===1?Math.PI/180:1,o=new G;n.queryEnvelope(o);const l=new G,_=new G,h=new G;l.setCoords({xmin:o.xmin,ymin:75*r,xmax:o.xmax,ymax:90*r}),_.setCoords({xmin:o.xmin,ymin:-60*r,xmax:o.xmax,ymax:75*r}),h.setCoords({xmin:o.xmin,ymin:-90*r,xmax:o.xmax,ymax:-60*r}),l.inflateCoords(.01*l.width(),0),_.inflateCoords(.01*_.width(),0),h.inflateCoords(.01*h.width(),0);let m=0;return m+=fe(n,l,t,i),m+=fe(n,_,t,i),m+=fe(n,h,t,i),m}function fe(u,e,t,s){const i=new be().execute(u,e,t,s);if(i!==null&&!i.isEmpty()){const a=new G;i.queryEnvelope(a);const{first:n,second:r}=ts(t,a,!1),o=le(t,n,null),l=new ne().execute(i,o,s).calculateArea2D();return r&&n.destroy(),l}return 0}const oe=[null,null,null,null,null,null,null];function es(u,e,t){const s=u.getUnit().getUnitToBaseFactor(),i=e.getCenter();i.scale(180*s/Math.PI);const a=new E;a.x=0,a.y=0;let n=0;if(n===0){i.y>45?(a.y=L,n=0):i.y<-45?(a.y=-L,n=1):i.x>=45&&i.x<135?(a.x=L,n=2):i.x>=135||i.x<-135?(a.x=L,n=3):i.x<-45&&i.x>=-135?(a.x=-L,n=4):(a.x=0,n=5);const P=s*Math.sqrt(Ne(e.xmin-e.xmax)+Ne(e.ymin-e.ymax)),S=a.clone(),y=e.getCenter();if(y.scale(s),n<2&&(S.x=y.x),E.distance(S,y)+.5*P>L)return null}const r=oe[n];if(r!==null&&r.getGCS().equalHorizontal(u))return r;const o=u.getText(),l=a.x,_=a.y,h=0,m=0;let c=0,p=-1;n!==6?p=$.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(ze(t),c=0,p=$.PE_PRJ_CYLINDRICAL_EQAREA);const g=Me("EqualAreaPCS");let f;p===$.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?f=`PROJCS["${g}",${o},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${l}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:p===$.PE_PRJ_CYLINDRICAL_EQAREA?f=`PROJCS["${g}",${o},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${c}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:se("getEqualAreaPcsFixed");const d=Le(f);return oe[n]&&oe[n].destroy(),oe[n]=d,d}function ts(u,e,t){const s=es(u,e,t);if(s!==null)return xe(s,!1);const i=u.getText(),a=u.getUnit().getUnitToBaseFactor(),n=(e.xmin+e.width()/2)*a,r=(e.ymin+e.height()/2)*a,o=0,l=0;let _=0,h=0,m=-1;e.ymin*a>=75*Math.PI/180||e.ymax*a<=-60*Math.PI/180?m=$.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:e.ymin>0||e.ymax<0?(_=(e.ymin+1/3*e.height())*a,h=(e.ymin+2/3*e.height())*a,m=$.PE_PRJ_ALBERS):(_=(e.ymin+2/3*e.height())*a,m=$.PE_PRJ_CYLINDRICAL_EQAREA);const c=Me("EqualAreaPCS");let p;return m===$.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?p=`PROJCS["${c}",${i},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${l}],PARAMETER["Central_Meridian",${n}],PARAMETER["Latitude_of_Origin",${r}],UNIT["Meter",1.0]]`:m===$.PE_PRJ_ALBERS?p=`PROJCS["${c}",${i},PROJECTION["Albers"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${l}],PARAMETER["Central_Meridian",${n}],PARAMETER["Standard_Parallel_1",${_}],PARAMETER["Standard_Parallel_2",${h}],PARAMETER["Latitude_of_Origin",${r}],UNIT["Meter",1.0]]`:m===$.PE_PRJ_CYLINDRICAL_EQAREA?p=`PROJCS["${c}",${i},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${l}],PARAMETER["Central_Meridian",${n}],PARAMETER["Standard_Parallel_1",${_}],PARAMETER["Latitude_of_Origin",${r}],UNIT["Meter",1.0]]`:se("getEqualAreaPCSInstance"),xe(Le(p),!0)}function ss(u,e,t){const s=u.calculateLength2D(),i=new je().execute(u,e,t)/25e3,a=s/u.getSegmentCount()*2;let n=Math.min(a,s/i);return n===0&&(n=1),xe(n,s/n)}class ns{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}execute(e,t,s){if(t.getCoordinateSystemType()===0&&me(""),e.isEmpty()||e.getDimension()<2)return 0;if(Te(e),e.getGeometryType()===Q.enumEnvelope){const l=new Ce;return l.addEnvelope(e,!1),this.execute(l,t,s)}let i=e;e.getDescription().getAttributeCount()>1&&(i=e.clone(),i.dropAllAttributes());const a=new ie().execute(i,0,t.getTolerance(0),0,s);let n=null;const r=t.getGCS();r!==t&&(n=le(t,r));let o=new Pe().execute(a,t,!1,s);return o.isEmpty()?0:(o===e&&(o=e.clone()),t.isPannable()?Wt(o,t,s):Kt(o,t,r,n,s))}}function Se(){return{m_p_PCS:new E,m_factor:Number.NaN,setValues:is,assign:as}}function is(u,e){this.m_factor=u,this.m_p_PCS.assign(e)}function as(u){this.m_factor=u.m_factor,this.m_p_PCS.assign(u.m_p_PCS)}class rs{constructor(e,t,s,i){this.m_ptStart=new x,this.m_ptEnd=new x,this.m_ptStart.assign(t),this.m_ptEnd.assign(s),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const a=Math.sin(i);let n;n=this.m_e2===0?2*a:a*(H(this.m_e*a)+1/(1-this.m_e2*a*a)),this.m_baseA=n}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,s=t*this.m_ptStart.x+e*this.m_ptEnd.x,i=t*this.m_ptStart.y+e*this.m_ptEnd.y,a=t*this.m_ptStart.z+e*this.m_ptEnd.z,n=s*s+i*i,r=a/Math.sqrt(a*a+this.m_c1MinusE2*this.m_c1MinusE2*n);let o;return this.m_e2===0?o=2*r:o=r*(H(this.m_e*r)+1/(1-this.m_e2*r*r)),(this.m_deltaY*s-this.m_deltaX*i)/n*(o-this.m_baseA)}}}function _s(){return{e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN}}function ye(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:os,changeSign:hs,assign:ms,clone:ls}}function os(u,e,t,s){const i=.5*u;this.sin_phi=Math.sin(u);const a=e*this.sin_phi,n=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(i+t),this.sin_half_phi_pz=Math.sin(i+s),this.sin_half_asin_e_sin_phi_pf=Math.sin(n+t),this.sin_half_asin_e_sin_phi_pz=Math.sin(n+s),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function hs(){this.sin_phi=-this.sin_phi;let u=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=u,u=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=u,u=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=u,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function ms(u){this.sin_phi=u.sin_phi,this.one_p_sin_phi=u.one_p_sin_phi,this.one_m_sin_phi=u.one_m_sin_phi,this.one_m_e_2_sin_2_phi=u.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=u.sin_half_phi_pf,this.sin_half_phi_pz=u.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=u.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=u.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=u.atanh_sin_phi,this.atanh_esin_phi=u.atanh_esin_phi,this.make_negative=u.make_negative}function ls(){return{...this}}class us{constructor(e,t,s){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new ce,this.m_scaleToDegrees=new ce,this.m_progressTracker=s,ze(t!==4),this.m_curveType=t,this.m_inputSR=e,e&&e.getCoordinateSystemType()!==0||me(""),this.m_inputGCS=e.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,s=e.clone();if(s.dropAllAttributes(),e.hasNonLinearSegments()&&(s=new ie().execute(s,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const n=new G;s.queryEnvelope(n);const r=this.m_inputSR.getPannableExtent();if(!r.containsEnvelope(n)){const o=r.getCenterX()-n.getCenterX(),l=new ce;l.setShiftCoords(o,0),s.applyTransformation(l),n.move(o,0);const _=new Ee;r.queryIntervalX(_);const h=new Ee;n.queryIntervalX(h),s=_.contains(h)?Ge(s,this.m_inputSR):new ne().foldInto360RangeGeodetic(s,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(s=new Pe().execute(s,this.m_inputSR,!1,this.m_progressTracker),t=s.createInstance(),De(this.m_transformPCS2GCS,s,t,this.m_progressTracker)||(t=new ne().execute(s,this.m_transformPCS2GCS,this.m_progressTracker))):t=new Pe().execute(s,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(this.m_curveType===1){const n=Z();return this.m_inputGCS.querySpheroidData(n),this.m_a=n.majorSemiAxis,this.m_eSquared=n.e2,this.loxodromeArea(t)}const i=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),i.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const a=Z();if(this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_b=a.minorSemiAxis,this.m_eSquared=a.e2,this.m_curveType===2)return this.executeClippedPolygonGreatEllipticArea(t);{const n={stack:[],error:void 0,hasError:!1};try{const r=pe.unit(9101),o=this.m_inputGCS.getPECoordSys(),l=U(n,o.cloneAlterUnits(r),!1);let _,h,m=this.executeClippedPolygonGeodeticArea(t,l,0),c=0;do c++,_=this.executeClippedPolygonGeodeticArea(t,l,c),h=Math.abs(_-m),m=_;while(Math.abs(_)>1&&h>1e-8*Math.abs(_)&&c<7);return _}catch(r){n.error=r,n.hasError=!0}finally{ee(n)}}}executeClippedPolygonGeodeticArea(e,t,s){const i={stack:[],error:void 0,hasError:!1};try{const a=new G;e.queryEnvelope(a);const n=U(i,this.getEqualAreaPCSInstance(t,a),!1),r=e.clone();Je(n,r);const o=50,l=r.getImpl().getAttributeStreamRef(0),_=e.getImpl().getAttributeStreamRef(0),h=U(i,new j,!1),m=U(i,new j,!1),c=40,p=[0,0],g=qe(Se,c),f=Ae(c,-1),d=Se(),P=Se();let S,y;const T=n;let C=r.calculateArea2D();const M=new K(0),O=.5*Math.PI,k=1e-10*Math.abs(C)+1e-6,Y=e.getPathCount();let q,I,R,A;const w=new E,N=new E,D=new E,X=new E,J=new E,z=new E;let W,ue;for(I=e.getPathStart(0),q=0;q<Y;q++,I=R)for(R=e.getPathEnd(q),l.queryPoint2D(R-1<<1,D),_.queryPoint2D(R-1<<1,w),Math.abs(w.y)>O&&(w.y=re(O,w.y)),A=I;A<R;A++,D.assign(X),w.assign(N)){if(l.queryPoint2D(A<<1,X),_.queryPoint2D(A<<1,N),Math.abs(N.y)>O&&(N.y=re(O,N.y)),W=E.distance(D,X),W<o||w.y===0&&N.y===0)continue;V.geodeticDistance(this.m_a,this.m_eSquared,w.x,w.y,N.x,N.y,h,m,null,this.m_curveType);const ke=h.val,Fe=m.val;for(d.setValues(0,D),P.setValues(1,X),y=s,g[0].assign(P),f[0]=s,S=0;S>=0;){ue=.5*(d.m_factor+P.m_factor),V.geodeticCoordinate(this.m_a,this.m_eSquared,w.x,w.y,ke*ue,Fe,h,m,this.m_curveType),J.x=h.val,J.y=m.val,p[0]=J.x,p[1]=J.y,te.geogToProj(T,1,p),z.x=p[0],z.y=p[1];const Ue=-z.offset(d.m_p_PCS,P.m_p_PCS),ae=.5*Ue*E.distance(d.m_p_PCS,P.m_p_PCS);if(M.pe(ae),Math.abs(ae)>k||Math.abs(ae)>0&&y>0)P.setValues(ue,z),S++,g[S].assign(P),Math.abs(ae)<=k?(y--,f[S-1]=y,f[S]=y):(y=f[S-1],f[S]=y);else{if(S<=0)break;d.assign(P),S--,P.assign(g[S]),y=f[S]}}}return C+=M.getResult(),Math.abs(C)}catch(a){i.error=a,i.hasError=!0}finally{ee(i)}}executeClippedPolygonGreatEllipticArea(e){const t=[],s=[],i=new E,a=new E,n=b(1,this.m_eSquared,new E(0,.5*Math.PI)),r=new K(0),o=new K(0),l=new K(0),_=new x,h=new x,m=new G;e.queryLooseEnvelope(m);let c=0;m.containsCoords(m.xmin,0)||(c=Math.abs(m.ymin)<Math.abs(m.ymax)?m.ymin:m.ymax);const p=new rs(this.m_eSquared,_,h,c),g=this.m_a*this.m_a,f=e.getImpl().querySegmentIterator();for(f.stripAttributes();f.nextPath();)for(;f.hasNextSegment();){const d=f.nextSegment();i.assign(d.getStartXY()),a.assign(d.getEndXY()),a.x-i.x>Math.PI?i.x+=2*Math.PI:a.x-i.x<-Math.PI&&(a.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(d,t,s);for(let P of t)_.assign(b(this.m_a,this.m_eSquared,P.getStartXY())),h.assign(b(this.m_a,this.m_eSquared,P.getEndXY())),p.setSegmentEndPoints(_,h),this.adaptiveIntegrationWithRomberg(p,r);for(let P of s){let S=P.getStartXY(),y=P.getEndXY(),T=c;S.y<0&&(y=Be(S,S=y),S.y=-S.y,y.y=-y.y,T=-T);const C=b(1,this.m_eSquared,S),M=b(1,this.m_eSquared,y),O=Math.min(S.y,y.y),k=Re(this.m_eSquared,S.x,y.x,T,O);o.pe(k);const Y=Math.abs(Re(this.m_eSquared,S.x,y.x,O,L)),q=new x;q.setSub(C,n);const I=new x;I.setSub(M,n);const R=new x;R.setCrossProductVector(q,I);let A=g*(Y-.5*R.length());A=re(A,y.x-S.x),l.pe(A)}t.length=0,s.length=0}return l.getResult()+g*(.5*(1-this.m_eSquared)*r.getResult()+o.getResult())}getEqualAreaPCSInstance(e,t){const s=t.getCenterX(),i=0,a=0;let n,r;const o=t.height();let l,_;(l=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?n=re(.5*Math.PI,t.getCenterY()):(n=t.getCenterY(),r=t.ymin+o*(2/3));const h=Me("EqualAreaPCS"),m=e.toString();return _=l?pe.fromString($.PE_TYPE_PROJCS,`PROJCS["${h}", ${m}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${s}], PARAMETER["Latitude_of_Origin", ${n}], UNIT["Meter",1.0]]`):pe.fromString($.PE_TYPE_PROJCS,`PROJCS["${h}", ${m}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", ${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${s}],PARAMETER["Standard_Parallel_1", ${r}],PARAMETER["Latitude_of_Origin", ${n}],UNIT["Meter",1.0]]`),_}splitSegmentCrossingItegralThreshold(e,t,s){const r=b(this.m_a,this.m_eSquared,new E(0,L)),o=b(this.m_a,this.m_eSquared,new E(0,-L)),l=this.splitSegmentPassingThroughPole(e);for(let _ of l){const h=_.getStartXY(),m=_.getEndXY(),c=b(this.m_a,this.m_eSquared,h),p=b(this.m_a,this.m_eSquared,m),g=new E,f=new x;let d=x.sqrDistance(r,c),P=x.sqrDistance(c,p);if(d<=100){if(!(P>400)){s.push(new v({start:h,end:m}));continue}f.assign(p.sub(c)),f.normalizeThis(),f.assign(c.add(f.mul(20))),g.assign(B(this.m_a,this.m_eSquared,f)),s.push(new v({start:h,end:g})),h.assign(g)}if(c.assign(b(this.m_a,this.m_eSquared,h)),d=x.sqrDistance(r,p),P=x.sqrDistance(c,p),d<=100){if(!(P>400)){s.push(new v({start:h,end:m}));continue}f.assign(p.sub(c)),f.normalizeThis(),f.assign(p.sub(f.mul(20))),g.assign(B(this.m_a,this.m_eSquared,f)),s.push(new v({start:g,end:m})),m.assign(g)}if(c.assign(b(this.m_a,this.m_eSquared,h)),p.assign(b(this.m_a,this.m_eSquared,m)),d=x.sqrDistance(o,c),P=x.sqrDistance(c,p),d<=100){if(!(P>400)){s.push(new v({start:h,end:m}));continue}f.assign(p.sub(c)),f.normalizeThis(),f.assign(c.add(f.mul(20))),g.assign(B(this.m_a,this.m_eSquared,f)),s.push(new v({start:h,end:g})),h.assign(g)}if(c.assign(b(this.m_a,this.m_eSquared,h)),p.assign(b(this.m_a,this.m_eSquared,m)),d=x.sqrDistance(o,p),P=x.sqrDistance(c,p),d<=100){if(!(P>400)){s.push(new v({start:h,end:m}));continue}f.assign(p.sub(c)),f.normalizeThis(),f.assign(p.sub(f.mul(20))),g.assign(B(this.m_a,this.m_eSquared,f)),s.push(new v({start:g,end:m})),m.assign(g)}t.push(new v({start:h,end:m}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const s=[],i=new x,a=new x,n=new x,r=new E,o=20,l=3.124139361,_=10,h=e.getStartXY(),m=e.getEndXY(),c=U(t,new j,!1);if(V.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,m.x,m.y,c,null,null,2),Math.abs(m.x-h.x)>l&&c.val>o){const p=new Qt(new E(0,90),h.divide(this.m_rpu),m.divide(this.m_rpu),this.m_inputGCS,2,2);let g=ve(p.makeFunctor(),0,1,1e-10);if(g.second<=_&&g.first>0&&g.first<1)return i.assign(b(this.m_a,this.m_eSquared,h)),a.assign(b(this.m_a,this.m_eSquared,m)),we(i,a,g.first,n),r.assign(B(this.m_a,this.m_eSquared,n)),s.push(new v({start:h,end:r})),s.push(new v({start:r,end:m})),s;if(p.setPointDistFrom(new E(0,-90)),g=ve(p.makeFunctor(),0,1,1e-10),g.second<=_&&g.first>0&&g.first<1)return i.assign(b(this.m_a,this.m_eSquared,h)),a.assign(b(this.m_a,this.m_eSquared,m)),we(i,a,g.first,n),r.assign(B(this.m_a,this.m_eSquared,n)),s.push(new v({start:h,end:r})),s.push(new v({start:r,end:m})),s}return s.push(new v({start:h,end:m})),s}catch(s){t.error=s,t.hasError=!0}finally{ee(t)}}adaptiveIntegrationWithRomberg(e,t){const s=e.makeFunctor();let i=0,a=1,n=s(i),r=s(a);const o=1e-17,l=1e-14;let _=(i+a)/2,h=s(_),m=Math.abs(h-n),c=Math.abs(r-h),p=0;for(;p++<32&&(m/c<.1||c/m<.1);)m<c?(t.pe(he(5,i,_,l,o,s)),i=_,n=h):(t.pe(he(5,_,a,l,o,s)),a=_,r=h),_=(i+a)/2,h=Math.abs(s(_)),m=Math.abs(h-n),c=Math.abs(r-h);t.pe(he(5,i,a,l,o,s))}loxodromeAreaHemi(e,t,s,i,a){const n=s.clone(),r=a.clone();let o,l,_,h,m,c,p,g,f,d,P,S,y,T,C,M;return n.make_negative&&n.changeSign(),r.make_negative&&r.changeSign(),P=i-t,Math.abs(n.sin_phi)===1||Math.abs(r.sin_phi)===1?e.half_qp*P:n.sin_phi===r.sin_phi?(d=.5*e.one_m_e_2*n.sin_phi*(1/n.one_m_e_2_sin_2_phi+H(e.e*n.sin_phi))*P,d):(C=Math.log(r.sin_half_phi_pf*n.sin_half_phi_pz/(r.sin_half_phi_pz*n.sin_half_phi_pf)),M=Math.log(r.sin_half_asin_e_sin_phi_pf*n.sin_half_asin_e_sin_phi_pz/(r.sin_half_asin_e_sin_phi_pz*n.sin_half_asin_e_sin_phi_pf)),this.m_eSquared===1?(m=0,o=.5*(C+r.sin_phi/r.one_m_e_2_sin_2_phi-n.sin_phi/n.one_m_e_2_sin_2_phi),l=0):(m=-2*e.atanh_e_over_e*(Math.log(r.one_p_sin_phi/n.one_p_sin_phi)-e.e*M),o=(C-e.e*M)/e.one_m_e_2,l=(Math.log(r.one_m_e_2_sin_2_phi/n.one_m_e_2_sin_2_phi)+m/e.atanh_e_over_e)/e.one_m_e_2),_=-M*(n.atanh_esin_phi+r.atanh_esin_phi),h=1/n.one_m_e_2_sin_2_phi-1/r.one_m_e_2_sin_2_phi,c=F(r.one_m_sin_phi/e.one_p_e,e.e)-F(n.one_m_sin_phi/e.one_p_e,e.e),p=F(r.one_p_sin_phi/e.one_p_e,e.e)-F(n.one_p_sin_phi/e.one_p_e,e.e),g=F(n.one_m_sin_phi/-e.one_m_e,e.e)-F(r.one_m_sin_phi/-e.one_m_e,e.e),f=F(n.one_p_sin_phi/-e.one_m_e,e.e)-F(r.one_p_sin_phi/-e.one_m_e,e.e),d=.25/o*(l+_+h+m+.5*(c+p+g+f)),d+=e.half_qp,S=.5*e.one_m_e_2*n.sin_phi*(1/n.one_m_e_2_sin_2_phi+H(e.e*n.sin_phi)),y=.5*e.one_m_e_2*r.sin_phi*(1/r.one_m_e_2_sin_2_phi+H(e.e*r.sin_phi)),y<S&&(T=S,S=y,y=T),d<S&&(d=S),d>y&&(d=y),d*=P,d)}loxodromeArea(e){const t=Math.PI/180;let s=0;const i=_s(),a=ye(),n=ye();i.e=Math.sqrt(this.m_eSquared),i.one_p_e=1+i.e,i.one_m_e=1-i.e,i.one_m_e_2=1-this.m_eSquared,i.atanh_e_over_e=H(i.e),this.m_eSquared>=1?i.half_qp=1:i.half_qp=.5*(1+i.atanh_e_over_e*i.one_m_e_2),i.f=.25*Math.PI,i.z=.75*Math.PI,n.initialize(0,i.e,i.f,i.z);const r=e.getPathCount(),o=new E,l=new E,_=e.getImpl().getAttributeStreamRef(0);for(let h=0;h<r;h++){const m=e.getPathStart(h),c=e.getPathEnd(h);if(!(c-m<=1)){_.queryPoint2D(2*(c-1),o);for(let p=m;p<c;p++){_.queryPoint2D(2*p,l);const g=o.y*t,f=l.y*t;if(p===m?(a.initialize(g,i.e,i.f,i.z),a.make_negative=!1):a.assign(n),n.initialize(f,i.e,i.f,i.z),n.make_negative=!1,o.y*l.y<0){if(o.y>=90&&l.y<=-90||l.y>=90&&o.y<=-90)return Number.NaN;const d=ye();d.initialize(0,i.e,i.f,i.z),d.make_negative=!1;const P=a.atanh_sin_phi-i.e*a.atanh_esin_phi,S=n.atanh_sin_phi-i.e*n.atanh_esin_phi,y=(S*o.x-P*l.x)/(S-P);g<0?(a.make_negative=!0,s-=this.loxodromeAreaHemi(i,o.x*t,a,y*t,d),a.make_negative=!1,s+=this.loxodromeAreaHemi(i,y*t,d,l.x*t,n)):(s+=this.loxodromeAreaHemi(i,o.x*t,a,y*t,d),n.make_negative=!0,s-=this.loxodromeAreaHemi(i,y*t,d,l.x*t,n),n.make_negative=!1)}else o.y>=0?s+=this.loxodromeAreaHemi(i,o.x*t,a,l.x*t,n):(a.make_negative=!0,n.make_negative=!0,s-=this.loxodromeAreaHemi(i,o.x*t,a,l.x*t,n),a.make_negative=!1,n.make_negative=!1);o.assign(l)}}}return this.m_a*s*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===Q.enumEnvelope){const t=new Ce;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&this.m_transformPCS2GCS===null&&(this.m_transformPCS2GCS=le(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class cs{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}execute(e,t,s,i){return Te(e),s===4?new ns().execute(e,t,i):new us(t,s,i).calculate(e)}}const zs=Object.freeze(Object.defineProperty({__proto__:null,OperatorGeodeticArea:cs},Symbol.toStringTag,{value:"Module"}));class ps{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}execute(e,t,s,i){if(s===4)return new je().execute(e,t,i);if(t.getCoordinateSystemType()===0&&me(""),Te(e),e.isEmpty()||e.getDimension()<1)return 0;const a=t.getGCS(),n=Z();a.querySpheroidData(n);const r=n.majorSemiAxis,o=n.e2,l=a.getUnit().getUnitToBaseFactor();let _;const h=e.getGeometryType();if(h===Q.enumPolygon?_=e.getBoundary():h===Q.enumEnvelope?_=He(e):Oe(h)?(_=new Ie({vd:e.getDescription()}),_.addSegment(e,!0)):_=e,_.hasNonLinearSegments()&&(_=new ie().execute(_,0,t.getTolerance(0),0,i)),a!==t){const m=t.getSRToGCSTransform();if(t.isPannable()){_=Ge(_,t),h===Q.enumPolyline&&_===e&&(_=e.clone());const p=new Ee;t.getPannableExtent().queryIntervalX(p);for(let g=0,f=_.getPointCount();g<f;g++){const d=_.getXY(g);d.x=Qe(d.x,p),_.setXY(g,d)}}const c=_.createInstance();_=De(m,_,c,i)?c:new ne().execute(_,m,i)}return this._ExecuteMultiPathGeodeticLength(_,s,r,o,l)}_ExecuteMultiPathGeodeticLength(e,t,s,i,a){const n={stack:[],error:void 0,hasError:!1};try{const r=U(n,new j,!1);let o=0;const l=e.querySegmentIterator();for(;l.nextPath();)for(;l.hasNextSegment();){const _=l.nextSegment(),h=_.getStartXY(),m=_.getEndXY();h.scale(a),m.scale(a),V.geodeticDistance(s,i,h.x,h.y,m.x,m.y,r,null,null,t),o+=r.val}return o}catch(r){n.error=r,n.hasError=!0}finally{ee(n)}}}const Gs=Object.freeze(Object.defineProperty({__proto__:null,OperatorGeodeticLength:ps},Symbol.toStringTag,{value:"Module"}));export{zs as O,ys as a,Es as b,Ps as c,xs as d,bs as e,As as f,Cs as g,Ts as h,Ms as i,Rs as j,vs as k,ws as l,Ns as m,Gs as n,$s as p,qs as r,Os as s};
